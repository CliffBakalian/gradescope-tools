package gradescope

import (
  "io"
  "log"
  "os"
  "encoding/csv"
  "regexp"
  "strconv"
  "math"
)

/*
var (
  submissionIDs = make(map[string]submission)
)
*/


const (
  max_tokens = 6
)

//Go through the csv file and make a list of grade structs
//where each struct has name, uid, grade, and time
func parseGradesFile(filename string) map[string]Submission{
  f, err := os.Open(filename)
  if err != nil {
    log.Fatal("Failed to open csv file")
  }

  defer f.Close()
  submissions := make(map[string]Submission)

  csvReader := csv.NewReader(f)
  csvReader.FieldsPerRecord = -1

  //get the time then date the assignmnet was submitted
  subtime_re := regexp.MustCompile(`(\d\d):(\d\d):(\d\d)`)
  subdate_re := regexp.MustCompile(`(\d{4})-(\d{2})-(\d{2})`)

  csvReader.Read()
  for {
    record, err := csvReader.Read()
    if err == io.EOF {
      break
    }
    //if login failed, then len < 2
    if err != nil || len(record) <2{
      f.Close()
      os.Remove(filename)
      log.Fatalln("Error parsing row. Make sure credentials correct",err)
    }

    firstName := record[0]
    lastName := record[1]
    userid := record[2]
    max_points, _ := strconv.ParseFloat(record[6], 32)    
    var points float64
    var subTime, lateTime Time
    var subDate Date

    //if assignment was not submitted, the length will notbe >8
    if record[7] == "Graded" {
      points, _ = strconv.ParseFloat(record[5], 32)    
      subdate := subdate_re.FindStringSubmatch(record[9])
      subtime := subtime_re.FindStringSubmatch(record[9])
      latetime := subtime_re.FindStringSubmatch(record[10])
      subTime = Time{
        hour: int16(func(x int,y error)int{return x}(strconv.Atoi(subtime[1]))),
        minute: int8(func(x int,y error)int{return x}(strconv.Atoi(subtime[2]))),
        seconds: int8(func(x int,y error)int{return x}(strconv.Atoi(subtime[3]))),
      }
      lateTime = Time{
        hour: int16(func(x int,y error)int{return x}(strconv.Atoi(latetime[1]))),
        minute: int8(func(x int,y error)int{return x}(strconv.Atoi(latetime[2]))),
        seconds: int8(func(x int,y error)int{return x}(strconv.Atoi(latetime[3]))),
      }
      subDate = Date{
        year: uint16(func(x int,y error)int{return x}(strconv.Atoi(subdate[1]))),
        month: int8(func(x int,y error)int{return x}(strconv.Atoi(subdate[2]))),
        day: int8(func(x int,y error)int{return x}(strconv.Atoi(subdate[3]))),
      }
    }else {
      //the assignment was not submmited so just use 0 for these
      points = 0.0
      subTime = Time{
        hour: 0,
        minute: 0,
        seconds: 0,
      }
      lateTime = subTime
      subDate = Date{
        year: 0,
        month: 0,
        day: 0,
      }
    }

    //create the grade node in the list
    sub := Submission{
      lname: lastName,
      fname: firstName,
      uid: userid,
      points: float32(points),
      maxPoints: float32(max_points),
      date: subDate,
      time: subTime,
      late: lateTime,
    }

    if _,exists := submissions[userid]; !exists{
      submissions[userid] = sub 
    }
  }
  return submissions
}

func WriteGrades(submissions map[string]Submission, tokens TokenList, assignName string){
  //will need to download file from canvas. You can do this in the grades tab and go to actions->export
  template, err := os.Open("template.csv") 
  if err != nil {
    log.Fatal("Failed to open template.csv.\nMake sure you downloaded this from Canvas")
  }
  defer template.Close()

  csvReader := csv.NewReader(template)
  csvReader.FieldsPerRecord = -1

  var to_write = [][]string{}
  header, err := csvReader.Read()
  header = header[:5]
  header = append(header,assignName)
  to_write = append(to_write,header)
  for {
    line, err := csvReader.Read()
    if err == io.EOF {
      break
    }
    line = line[:5]

    uid := line[2]
    submission := submissions[uid]
    tokenCount := 0 
    if _,exists:= studentIDs[uid]; exists{
      tokenCount = tokens.Students[studentIDs[uid]].Tokens
    }
    if tokenCount > max_tokens{
      log.Print(submission.lname)
      line = append(line,"0.00")
    }else{
      line = append(line,strconv.FormatFloat(float64(submission.points),'f',2,32))
    }
    to_write = append(to_write,line)
  }
  f,err := os.Create(assignName+"-grades.csv")
  writer := csv.NewWriter(f)
  err = writer.WriteAll(to_write)
  if err != nil{
    log.Println(err)
  }
}

//Because I was dumb and have Exam 1 9:30, and Exam 1 3:30 and I just want Exam 1
//This is all dependent that the two files were first generated by WriteGrades
//otherwise the order of people will not line up
func MergeGrades(assign1 string, assign2 string){
  file1, err := os.Open(assign1)
  if err != nil {
    log.Fatal("Failed to open "+assign1)
  }
  file2, err := os.Open(assign2)
  if err != nil {
    log.Fatal("Failed to open "+assign2)
  }
  reader1 := csv.NewReader(file1)
  reader1.FieldsPerRecord = -1

  reader2 := csv.NewReader(file2)
  reader2.FieldsPerRecord = -1

  var to_write = [][]string{}
  header, err := reader1.Read()
  to_write = append(to_write,header)
  reader2.Read()

  for {
    line1, err := reader1.Read()
    if err == io.EOF {
      break
    }
    line2, err := reader2.Read()
    if err == io.EOF {
      break
    }
    if len(line1) == len(line2){
      for i :=0; i < len(line1) - 5; i++ {
        val1,_ := strconv.ParseFloat(line1[i+5],32)
        val2,_ := strconv.ParseFloat(line2[i+5],32)
        line1[i+5] = strconv.FormatFloat(math.Max(val1,val2),'f',2,32)
      }
    }
    to_write = append(to_write,line1)
  }
  f,err := os.Create(assign1+"-merged-grades.csv")
  writer := csv.NewWriter(f)
  err = writer.WriteAll(to_write)
  if err != nil{
    log.Println(err)
  }
}
